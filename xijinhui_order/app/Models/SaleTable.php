<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SaleTable extends Model
{
    use HasFactory;
    public $incrementing = false;
    protected $keyType = 'string';

    protected $table = 'sale_tables';

    protected $fillable = [
        'dining_table_id',
        'sale_payment_id',
        'user_id',
        'sale_order_number',
        'showing_invoice_number',
        'invoice_number',
        'sale_date',
        'exchange_rate',
        'person_count',
        'total_amount',
        'discount_percentage',
        'discount_amount',
        'tax_amount',
        'room_service_amount',
        'grand_total',
        'received_dollar',
        'received_riel',
        'return_dollars',
        'return_riels',
        'balance_dollars',
        'remark',
        'finished_dining_date',
        'take_time',
        'pre_receipt_print_time',
        'receipt_print_time',
        'making_status',
        'status_code',
        'tax_declaration',
        'clearing_user_id',
        'clearing_datetime',
        'created_at',
        'updated_at',
        'is_secret',
        'secret_id',
    ];
    protected $hidden = [
        //'created_at',
        'updated_at',
    ];
    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    protected $appends = ['owed_amount'];

    public function getOwedAmountAttribute()
    {
        $received = $this->received_dollar + ($this->received_riel * $this->exchange_rate);
        return max($this->grand_total - $received, 0);
    }

    public function payOwed()
    {
        return $this->hasOne(PayOwed::class);
    }

    public function sale_detail()
    {
        return $this->hasMany(SaleDetail::class);
    }

    public function secretSale()
    {
        return $this->belongsTo(SaleTable::class, 'secret_id');
    }

    public function publicSale()
    {
        return $this->hasOne(SaleTable::class, 'secret_id');
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function dining_table()
    {
        return $this->belongsTo(DiningTable::class);
    }

    public function payments()
    {
        return $this->hasMany(Payment::class);
    }

    protected static function boot()
    {
        parent::boot();

        static::creating(function ($model) {
            if (empty($model->{$model->getKeyName()})) {
                $model->{$model->getKeyName()} = (string) uuid_create();
            }
        });
    }

    protected static function booted()
    {
        self::updating(
            function ($model) {
                $dingTable = DiningTable::find($model->dining_table_id);
                $model->total_amount = $model->sale_detail->sum('total_amount_after_discount');
                $model->tax_amount = ($model->total_amount * ($dingTable->tax_percentage / 100)) + $dingTable->tax_fixPrice;;
                $model->room_service_amount = ($model->total_amount * ($dingTable->room_service_percentage / 100)) + $dingTable->room_service_fixPrice;
                $model->discount_amount = $model->total_amount * ($model->discount_percentage / 100);
                $model->grand_total = ($model->total_amount - $model->discount_amount) + $model->tax_amount + $model->room_service_amount;
            }

        );

        parent::boot(); // TODO: Change the autogenerated stub
    }

    public function makeInvoiceNumber($number)
    {
        return 'INV-' . sprintf('%06d', $number);
    }

    public function getNextInvoiceNumber(): string
    {
        $lastOrder = SaleTable::whereNotNull('invoice_number')->orderBy('invoice_number', 'desc')->first();

        if (!$lastOrder)
            $number = 0;
        else
            $number = substr($lastOrder->invoice_number, 4);

        return 'INV-' . sprintf('%06d', intval($number) + 1);
    }

    public function getNextShowingInvoiceNumber()
    {
        $lastOrder = SaleTable::whereNotNull('showing_invoice_number')->orderBy('created_at', 'desc')->first();

        if (!$lastOrder)
            $number = 0;
        else
            $number = substr($lastOrder->showing_invoice_number, 4);

        $number = intval($number);

        // check invoice set
        $invoiceSet = SetInvoice::whereDate('invoice_date', now())->first();
        if ($invoiceSet && $invoiceSet->invoice_end <= $number) {
            $number = 0;
            return null;
        }

        return 'INV-' . sprintf('%06d', $number + 1);
    }

    public function duplicateForPublic($invoiceNumber = null)
    {
        $saleTable = $this->refresh();
        $pubSale = $saleTable->replicate()->fill([
            'invoice_number' => null,
            'showing_invoice_number' => $invoiceNumber ? $this->makeInvoiceNumber($invoiceNumber) : $this->getNextShowingInvoiceNumber(),
            'is_secret' => false,
            'secret_id' => $saleTable->id,
        ]);
        $pubSale->save();
        $pubSale = $pubSale->refresh();
        foreach ($this->sale_detail as $sd) {
            $sDetail = $sd->replicate()->fill([
                'sale_table_id' => $pubSale->id,
            ]);
            $sDetail->save();
            $pubSDetail = $sDetail->refresh();
            foreach (($sd->saleDetailIngredients ?? []) as $sdi) {
                $sDetailIngredient = $sdi->replicate()->fill([
                    'sale_detail_id' => $pubSDetail->id,
                ]);
                $sDetailIngredient->save();
            }
        }
        foreach ($this->payments as $p) {
            $pm = $p->replicate()->fill([
                'sale_table_id' => $pubSale->id,
            ]);
            $pm->save();
        }
        return $pubSale;
    }

    public function createPayOwed($date)
    {
        if ($this->is_secret) {
            $priSale = $this;
            $pubSale = $this->publicSale;
        } else {
            $priSale = $this->secretSale;
            $pubSale = $this;
        }

        $data = [
            'paid_at' => $date,
            'amount' => $this->grand_total,
            'user_id' => auth()->user()->id,
        ];

        $pubOwe = $pubSale->payOwed()->create($data);
        $priOwe = $priSale->payOwed()->create($data);
        if ($priSale->id == $this->id) {
            return $priOwe;
        }
        return $pubOwe;
    }
}
